# 树

## 复习

（1）遍历

> 前，中，后序遍历都不是树遍历的本质，树遍历的本质是递归序

什么叫递归序？







**递归写法**

**非递归写法**

**前序遍历的非递归写法**

> 头左 右 ：单个栈 如果有先压右树，如果有在压左树，不解释

后序遍历的非递归写法

> 头 右 左 ：单个栈，如果有先压左树，如果有在压右树，
>
> 不打印，而是压如另外一个栈，依次弹出
>
> 就是左右头的顺序了

中序遍历

> 先把树的**整个左边界**全压入栈
>
> 直接记

把所有左边界都压到栈里面



深度优先遍历：前中后序都属于

广度优先遍历：层序遍历

> 不使用递归算法，使用队列
>
> 无权图的最短路径的标准解法 

（2）二叉树的顺序性

后继节点：在中序遍历的节点中，节点的下一个节点

（3）递归序

> 递归可以访问一个节点**三次**



## 题目

（1）求树的最大宽度

（2）二叉树的序列化和反序列化（彻底还原树结构）

（3）打印整棵树

（4）返回前驱或者后继节点

中序遍历序下的后节点

> 怎么找？左树上最后打印的节点
>
> 子是父的右孩子

（5）![题目](https://kaikaimd.oss-cn-beijing.aliyuncs.com/md/题目.png)





二叉树的递归套路：

在树上做动态规划

（6）给定一颗二叉树的头节点head，返回这颗二叉树是不是平衡二叉树（每一颗子树的左子树和右子树高度差不超过一）

左子树可以给我信息，右子树也是可以给我信息的



1）左树也平衡的 2）右树也是平衡的 3）高度差<2





(7)

(8)给定一颗二叉树的头节点head，返回这颗二叉树中的最大的二叉搜索子树的头节点/最大节点

> 搜索二叉树



