# 技巧

## 异或运算

> 如何理解？
>
> 就是不进位的加法

0）如何得到有个整数最右边的一的数？

```java
int rightOne = eO & (~eO + 1);
```



1）【士】题目一：不用额外变量交换两个整数的值

> 如果内存中的值是相等的那么就适合用这种方法，比如：
>
> **注意**：在数组中，如果对相同的位置进行这种操作，那么这个索引位的值会变成0



2)【校】题目二：不用任何判断比较找出两个数中较大的数

3）【尉】整数的二进制表达中有多少个1？

4）【尉】在其他书都出现偶数次的数组中找到出现奇数次的数

```java 
    //给定一个整形数组 arr,其中只有一个数字出现了奇数次，其他数都出现了偶数次，打印这个数字
    void test1(int[] arr) {
        int e = 0;
        for (int i : arr) {
            e ^= i;
        }
        System.out.println(e);
    }

    //进阶：给定一个整形数组 arr,其中有两个数字出现了奇数次，其他数都出现了偶数次，打印这个数字
    void test2(int[] arr) {
        int eO = 0, eHasOne = 0;
        for (int curNum : arr) {
            eO ^= curNum;
        }
        int rightOne = eO & (~eO + 1);
        for (int cur : arr) {
            if ((cur & rightOne) != 0) {
                eHasOne ^= cur;
            }
        }
        System.out.println(eHasOne + " " + (eO ^ eHasOne));
    }
```





# 大数据或者空间限制

## 一致性hash算法

（1）普通方案的做法，存在的问题？

> 情景：在使用集群进行数据缓存的时候
>
> 在增加或者删除机器的时候，这个时候N会变化，那么**所有的数据ID**需要需要通过**哈希函数**重新计算Hash值，然后对现在的机器数进行取模，映射。然后就是需要对数据进行大规模的迁移

（2）一致性哈希算法

1）根据数据ID哈希值范围形成一个环

2）机器根据哈希函数计算出在这个环上的位置

3）数据通过顺时针归属于最近的一台机器

4）增加、删除机器。**一段一段**的数据迁移	

（3）一致性哈希的问题，以及解决办法

> 机器数较少的时候，数据负载不均匀，数据倾斜的问题
>
> 引入虚拟节点机制
>
> 怎么解决？增加虚拟的节点，增加平衡性

一台机器通过不同的哈希函数计算出多个哈希值，对多个位置存放服务节点，称为虚拟节点

节点变多了，那么数据之间的平衡性自然会变好







