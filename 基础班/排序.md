# 1.O(n^2)的排序算法

每次比较行为，只是让一个位置的数有序，浪费了比较行为



0 到N-1上的比较

1到N-1上的比较

2到N-1的比较

> 浪费了比较行为，每次比较只确定了一个数的位置

# 2.O(nlogn)的排序算法

## 归并排序

### 复杂度

时间:O(N*logN)

merge过程需要辅助数组，所以需要额外的空间复杂度O(N)

**归并排序的实质是把比较行为变成了有序信息并且传递**

### 递归实现和非递归实现



非递归复杂度



## 快速排序

partition的过程

给定一个数组arr，和一个整数num。请把小于等于num的数放在数组的左边。大于num的数放在数组的右边。

额外空间复杂度O(1)，时间复杂度O(N)

```java

```



# 3.理解排序



**题目一**(归并排序)：

在一个数组中，一个数左边比他小的数的总和，叫做数的小和，所有数的小和累加起来，叫做数组小和，求小和数组

例子：[1,3,4,2,5]

1左边比1小的数：没有

3左边比3小的数：1

4左边比2小的数：1、3

2左边比2小的数：1

5左边比5小的数：1、3、4、2

所以最终的小和就是：1+1+3+1+1+3+4+2

> 最优题解：实际是理解归并的过程，在merge 过程中，来统计小和，因为只要是Merge，两边的数组就是内部有序外部无序的，所以可以直接统计

merge的过程中产生小和，产生多少小和呢？左组某位置比右组某位置小就产生多少（可以通过下标计算出来）的小和，依次累加。相等时候，先拷贝右组

学会写**对数器**：每个数暴力的在左边寻找，O（n^2）



使用题型;

一个数字，左边有多少比你小、大

一个数字，右边有多少比你小、大

```java

```



求逆序对

求一个数，左边有多少数比他大就完事了





**题目二**（partition过程）：

荷兰国旗问题(partition过程)

在[L,R]做partition过程

