# 树

## 复习

（1）遍历

> 前，中，后序遍历都不是树遍历的本质，树遍历的本质是递归序

什么叫递归序？

每个节点都会到达三次，



树上的动态规划？

每个节点都可以去左树转一圈，右树转一圈，收集左右两颗子树的信息，最终回到次节点（树上做动态规划的基础）





**递归写法**

**非递归写法**（面试常考）

**前序遍历的非递归写法**

> 头左 右 ：单个栈 如果有先压右树，如果有在压左树，不解释

后序遍历的非递归写法

> 头 右 左 ：单个栈，如果有先压左树，如果有在压右树，
>
> 不打印，而是压如另外一个栈，依次弹出
>
> 就是左右头的顺序了

中序遍历

> 先把树的**整个左边界**全压入栈
>
> 直接记

把所有左边界都压到栈里面



深度优先遍历：前中后序都属于

广度优先遍历：层序遍历

> 不使用递归算法，使用队列
>
> 无权图的最短路径的标准解法 

（2）二叉树的顺序性

后继节点：在中序遍历的节点中，节点的下一个节点

（3）递归序

> 递归可以访问一个节点**三次**



## 题目

（1）求二叉树的最大宽度（常考）

> 就是层序遍历，但是发现每层的开始和结束
>
> 但是必须记录每层的宽度
>
> 左：按照层打印和求最大宽度，建立一种，层结束的机制，经常考

（2）二叉树的序列化和反序列化（彻底还原树结构）(常考)

> 左：很多变化
>
> 可以按照前、中、后序的方式进行序列化

序列化：只是记录顺序的话，无法完全还原树结构，必须记录空的节点（每个节点的空都不能忽略，）。拿空把位置补全，表示占位了已经

反序列化：空的目的，反序列化的时候，用来判断结束



例子：







（3）设计一颗可以打印整棵二叉树的函数

（4）返回前驱或者后继节点

中序遍历序下的后节点

> 怎么找？左树上最后打印的节点
>
> 子是父的右孩子

（5）![题目](https://kaikaimd.oss-cn-beijing.aliyuncs.com/md/题目.png)





二叉树的递归套路：

在树上做动态规划

（6）给定一颗二叉树的头节点head，返回这颗二叉树是不是平衡二叉树（每一颗子树的左子树和右子树高度差不超过一）

左子树可以给我信息，右子树也是可以给我信息的



1）左树也平衡的 2）右树也是平衡的 3）高度差<2





(7)

(8)给定一颗二叉树的头节点head，返回这颗二叉树中的最大的二叉搜索子树的头节点/最大节点

> 搜索二叉树



